#include <assimp/Importer.hpp>
#include <assimp/scene.h>
#include <assimp/postprocess.h>
#include <vector>
#include <iostream>
#include <string>
#include <algorithm>
#define STB_IMAGE_IMPLEMENTATION
#include <stb_image.h>

#define GLM_ENABLE_EXPERIMENTAL
#include <glm/glm.hpp>
#include <glm/vec3.hpp>
#include <glm/vec2.hpp>
#include <glm/mat4x4.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtx/quaternion.hpp>

#if defined(_WIN32)
#include <GL/glew.h>
#include <direct.h> // For _getcwd on Windows
#elif defined(__APPLE__) || defined(__linux__)
#include <OpenGL/gl3.h>>
#include <unistd.h> // For getcwd on Linux/macOS
#endif

#include <GLFW/glfw3.h>

// Include your camera file
#include "camera.h" // Make sure camera.h is in the same directory or include path

// Structure definitions
struct Vertex {
    glm::vec3 position;
    glm::vec3 normal;
    glm::vec2 texCoords;
};

struct Mesh {
    std::vector<Vertex> vertices;
    std::vector<unsigned int> indices;
    GLuint VAO;
    GLuint textureID; // For diffuse texture
    GLuint specularTextureID; // For specular texture
};

// Function to get the directory from a file path
std::string getDirectoryFromPath(const std::string& filePath) {
    size_t lastSlash = filePath.find_last_of("/\\");
    if (std::string::npos != lastSlash) {
        return filePath.substr(0, lastSlash + 1);
    }
    return "./";
}

// Function to set up a Mesh's VAO
GLuint setupMesh(const Mesh& mesh) {
    GLuint VAO;
    glCreateVertexArrays(1, &VAO);
    glBindVertexArray(VAO);
    GLuint VBO;
    glCreateBuffers(1, &VBO);
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, mesh.vertices.size() * sizeof(Vertex), &mesh.vertices[0], GL_STATIC_DRAW);
    GLuint EBO;
    glCreateBuffers(1, &EBO);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, mesh.indices.size() * sizeof(unsigned int), &mesh.indices[0], GL_STATIC_DRAW);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, normal));
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, texCoords));
    glEnableVertexAttribArray(2);
    glBindVertexArray(0);
    return VAO;
}

// Function to load LDR textures (JPEG, PNG, etc.), distinguishes between diffuse and specular
GLuint loadTexture(const std::string& path) {
    GLuint textureID = 0;
    int width, height, nrChannels;
    stbi_set_flip_vertically_on_load(true); // Useful for OpenGL
    unsigned char* data = stbi_load(path.c_str(), &width, &height, &nrChannels, 0);
    if (data) {
        glCreateTextures(GL_TEXTURE_2D, 1, &textureID);
        glBindTexture(GL_TEXTURE_2D, textureID);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        GLenum format = 0;
        if (nrChannels == 1) format = GL_RED;
        else if (nrChannels == 3) format = GL_RGB;
        else if (nrChannels == 4) format = GL_RGBA;
        else { stbi_image_free(data); glDeleteTextures(1, &textureID); return 0; }
        glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data);
        glGenerateMipmap(GL_TEXTURE_2D);
        stbi_image_free(data);
    }
    else {
        std::cerr << "Failed to load LDR texture: " << path << " | Error: " << stbi_failure_reason() << std::endl;
        return 0;
    }
    glBindTexture(GL_TEXTURE_2D, 0);
    stbi_set_flip_vertically_on_load(false); // Reset
    return textureID;
}

// NEW FUNCTION to load an equirectangular HDR texture
GLuint loadHDREquirectangularTexture(const std::string& path) {
    GLuint textureID = 0;
    stbi_set_flip_vertically_on_load(true); // HDR equirectangular often needs Y-flip
    int width, height, nrChannels;
    float* data = stbi_loadf(path.c_str(), &width, &height, &nrChannels, 0); // stbi_loadf for HDR
    if (data) {
        glGenTextures(1, &textureID);
        glBindTexture(GL_TEXTURE_2D, textureID);
        // Use high-precision internal format for HDR
        // GL_RGB16F or GL_RGB32F are common. GL_RGB16F is generally sufficient.
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB16F, width, height, 0, GL_RGB, GL_FLOAT, data);

        // No mipmaps for equirectangular in this simple case, use GL_LINEAR
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

        stbi_image_free(data);
    } else {
        std::cerr << "Failed to load HDR image: " << path << " | Error: " << stbi_failure_reason() << std::endl;
        return 0;
    }
    glBindTexture(GL_TEXTURE_2D, 0);
    stbi_set_flip_vertically_on_load(false); // Reset
    return textureID;
}


// The original loadCubemap function will no longer be used if HDR equirectangular is loaded
/*
GLuint loadCubemap(std::vector<std::string> faces)
{
    GLuint textureID;
    glGenTextures(1, &textureID);
    glBindTexture(GL_TEXTURE_CUBE_MAP, textureID);

    int width, height, nrChannels;
    stbi_set_flip_vertically_on_load(false);
    for (unsigned int i = 0; i < faces.size(); i++)
    {
        unsigned char* data = stbi_load(faces[i].c_str(), &width, &height, &nrChannels, 0);
        if (data)
        {
            GLenum format = GL_RGB;
            if (nrChannels == 4) format = GL_RGBA;
            glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data);
            stbi_image_free(data);
        }
        else
        {
            std::cerr << "Cubemap texture failed to load at path: " << faces[i] << " | Error: " << stbi_failure_reason() << std::endl;
            stbi_image_free(data);
            return 0;
        }
    }
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
    glBindTexture(GL_TEXTURE_CUBE_MAP, 0);
    stbi_set_flip_vertically_on_load(true);
    return textureID;
}
*/

// Default 1x1 white texture for specular maps not provided by the model
GLuint white1x1TextureID = 0;

void processNode(aiNode* node, const aiScene* scene, std::vector<Mesh>& meshes, const std::string& modelDirectory);

// Processes an Assimp mesh
Mesh processMesh(aiMesh* mesh, const aiScene* scene, const std::string& modelDirectory) {
    std::vector<Vertex> vertices;
    std::vector<unsigned int> indices;
    for (unsigned int i = 0; i < mesh->mNumVertices; i++) {
        Vertex vertex;
        vertex.position = glm::vec3(mesh->mVertices[i].x, mesh->mVertices[i].y, mesh->mVertices[i].z);
        vertex.normal = mesh->HasNormals() ? glm::vec3(mesh->mNormals[i].x, mesh->mNormals[i].y, mesh->mNormals[i].z) : glm::vec3(0.0f, 0.0f, 0.0f);
        vertex.texCoords = mesh->mTextureCoords[0] ? glm::vec2(mesh->mTextureCoords[0][i].x, mesh->mTextureCoords[0][i].y) : glm::vec2(0.0f, 0.0f);
        vertices.push_back(vertex);
    }
    for (unsigned int i = 0; i < mesh->mNumFaces; i++) {
        aiFace face = mesh->mFaces[i];
        for (unsigned int j = 0; j < face.mNumIndices; j++) indices.push_back(face.mIndices[j]);
    }

    Mesh processedMesh = { vertices, indices, 0, 0, 0 }; // Initialize specularTextureID to 0

    // Load textures from Assimp material
    if (mesh->mMaterialIndex >= 0) {
        aiMaterial* material = scene->mMaterials[mesh->mMaterialIndex];
        aiString str;

        // Load diffuse texture
        if (material->GetTexture(aiTextureType_DIFFUSE, 0, &str) == AI_SUCCESS) {
            std::string tFileName = str.C_Str();
            std::string fTexPath;
            // Check if the texture path is absolute (e.g., C:/, /home/, or http://)
            bool isAbs = (tFileName.length() > 2 && ((tFileName[1] == ':' && (tFileName[0] >= 'A' && tFileName[0] <= 'Z')) || (tFileName[1] == ':' && (tFileName[0] >= 'a' && tFileName[0] <= 'z')) || tFileName[0] == '/' || tFileName[0] == '\\' || tFileName.rfind("http://", 0) == 0 || tFileName.rfind("https://", 0) == 0));
            if (isAbs) fTexPath = tFileName;
            else {
                std::replace(tFileName.begin(), tFileName.end(), '\\', '/'); // Normalize slashes
                // If the model has paths relative to its own directory
                if (modelDirectory != "./" && tFileName.rfind("../", 0) != 0) {
                    fTexPath = modelDirectory + tFileName;
                }
                else {
                    fTexPath = tFileName; // Path relative to execution directory
                }
            }
            processedMesh.textureID = loadTexture(fTexPath);
        }

        // Load specular texture (if it exists)
        if (material->GetTexture(aiTextureType_SPECULAR, 0, &str) == AI_SUCCESS) {
            std::string tFileName = str.C_Str();
            std::string fTexPath;
            bool isAbs = (tFileName.length() > 2 && ((tFileName[1] == ':' && (tFileName[0] >= 'A' && tFileName[0] <= 'Z')) || (tFileName[1] == ':' && (tFileName[0] >= 'a' && tFileName[0] <= 'z')) || tFileName[0] == '/' || tFileName[0] == '\\' || tFileName.rfind("http://", 0) == 0 || tFileName.rfind("https://", 0) == 0));
            if (isAbs) fTexPath = tFileName;
            else {
                std::replace(tFileName.begin(), tFileName.end(), '\\', '/');
                if (modelDirectory != "./" && tFileName.rfind("../", 0) != 0) {
                    fTexPath = modelDirectory + tFileName;
                }
                else {
                    fTexPath = tFileName;
                }
            }
            processedMesh.specularTextureID = loadTexture(fTexPath);
        }
    }
    processedMesh.VAO = setupMesh(processedMesh);
    return processedMesh;
}

// Recursively processes an Assimp node
void processNode(aiNode* node, const aiScene* scene, std::vector<Mesh>& meshes, const std::string& modelDirectory) {
    for (unsigned int i = 0; i < node->mNumMeshes; i++) meshes.push_back(processMesh(scene->mMeshes[node->mMeshes[i]], scene, modelDirectory));
    for (unsigned int i = 0; i < node->mNumChildren; i++) processNode(node->mChildren[i], scene, meshes, modelDirectory);
}

// Loads a model using Assimp
std::vector<Mesh> loadModel(const std::string& path) {
    Assimp::Importer importer;
    const aiScene* scene = importer.ReadFile(path, aiProcess_Triangulate | aiProcess_GenSmoothNormals | aiProcess_FlipUVs | aiProcess_CalcTangentSpace);
    if (!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !scene->mRootNode) { std::cerr << "ASSIMP ERROR: " << importer.GetErrorString() << std::endl; return {}; }
    std::string modelDir = getDirectoryFromPath(path);
    std::vector<Mesh> meshes; processNode(scene->mRootNode, scene, meshes, modelDir); return meshes;
}

// Renders a mesh
void renderMesh(const Mesh& mesh, GLuint shaderProgram) {
    // Activate and bind diffuse texture
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, mesh.textureID);

    // Activate and bind specular texture. If none is specific, use the default white texture.
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, (mesh.specularTextureID != 0) ? mesh.specularTextureID : white1x1TextureID);

    glBindVertexArray(mesh.VAO);
    glDrawElements(GL_TRIANGLES, static_cast<GLsizei>(mesh.indices.size()), GL_UNSIGNED_INT, 0);
    glBindVertexArray(0);

    // Deactivate textures after rendering to avoid unwanted effects
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, 0);
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, 0);
}

// Function to compile shaders
GLuint compileShader(GLenum type, const char* source) {
    GLuint shader = glCreateShader(type);
    glShaderSource(shader, 1, &source, NULL);
    glCompileShader(shader);

    int success;
    char infoLog[1024];
    glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
    if (!success) {
        glGetShaderInfoLog(shader, 1024, NULL, infoLog);
        std::cerr << "SHADER_COMPILATION_ERROR of type " << type << ":\n" << infoLog << std::endl;
        glDeleteShader(shader);
        return 0;
    }
    return shader;
}

// Function to create and link a shader program
GLuint createShaderProgram(const char* vsSource, const char* fsSource) {
    GLuint vertexShader = compileShader(GL_VERTEX_SHADER, vsSource);
    GLuint fragmentShader = compileShader(GL_FRAGMENT_SHADER, fsSource);

    if (vertexShader == 0 || fragmentShader == 0) {
        return 0; // Error in compiling one of the shaders
    }

    GLuint program = glCreateProgram();
    glAttachShader(program, vertexShader);
    glAttachShader(program, fragmentShader);
    glLinkProgram(program);

    int success;
    char infoLog[1024];
    glGetProgramiv(program, GL_LINK_STATUS, &success);
    if (!success) {
        glGetProgramInfoLog(program, 1024, NULL, infoLog);
        std::cerr << "SHADER_PROGRAM_LINKING_ERROR:\n" << infoLog << std::endl;
        glDeleteProgram(program);
        program = 0;
    }

    glDeleteShader(vertexShader); // Delete shaders once linked to the program
    glDeleteShader(fragmentShader);
    return program;
}

// Camera instance globally
Camera camera(glm::vec3(0.0f, 11.0f, 3.0f));

// Variables for mouse handling and flashlight
float lastX;
float lastY;
bool firstMouse = true;
bool flashlightOn = true; // Flashlight on/off control

// Input processing function
void processInput(GLFWwindow* window, float deltaTime) {
    // Use the ProcessKeyboard function from the Camera class
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
        glfwSetWindowShouldClose(window, true);
    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
        camera.ProcessKeyboard(FORWARD, deltaTime);
    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
        camera.ProcessKeyboard(BACKWARD, deltaTime);
    if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
        camera.ProcessKeyboard(LEFT, deltaTime);
    if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
        camera.ProcessKeyboard(RIGHT, deltaTime);

    // Flashlight toggle
    static bool l_key_pressed = false;
    if (glfwGetKey(window, GLFW_KEY_L) == GLFW_PRESS && !l_key_pressed) {
        flashlightOn = !flashlightOn;
        l_key_pressed = true;
    }
    if (glfwGetKey(window, GLFW_KEY_L) == GLFW_RELEASE) {
        l_key_pressed = false;
    }
}

// Mouse movement callback
void mouse_callback(GLFWwindow* window, double xposIn, double yposIn) {
    float xpos = static_cast<float>(xposIn);
    float ypos = static_cast<float>(yposIn);

    if (firstMouse) {
        lastX = xpos;
        lastY = ypos;
        firstMouse = false;
    }

    float xoffset = xpos - lastX;
    float yoffset = lastY - ypos; // Inverted, as Y-coordinates of the mouse go from bottom to top

    lastX = xpos;
    lastY = ypos;

    camera.ProcessMouseMovement(xoffset, yoffset);
}

int main() {
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
#ifdef __APPLE__
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
#endif
    unsigned int sW = 2200, sH = 1900;
    lastX = static_cast<float>(sW) / 2.0f;
    lastY = static_cast<float>(sH) / 2.0f;
    GLFWwindow* win = glfwCreateWindow(sW, sH, "3D Model", nullptr, nullptr);
    if (!win) {
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(win);
    glfwSetInputMode(win, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
    glfwSetCursorPosCallback(win, mouse_callback);

#if defined(_WIN32)
    if (glewInit() != GLEW_OK) {
        glfwTerminate();
        return -1;
    }
#endif

    char buffer[FILENAME_MAX];
#ifdef _WIN32
    if (_getcwd(buffer, sizeof(buffer)) != NULL) {
        std::cout << "Current working directory: " << buffer << std::endl;
    }
    else {
        std::cerr << "Error getting current working directory." << std::endl;
    }
#else // For __APPLE__ and __linux__
    if (getcwd(buffer, sizeof(buffer)) != NULL) {
        std::cout << "Current working directory: " << buffer << std::endl;
    }
    else {
        std::cerr << "Error getting current working directory." << std::endl;
    }
#endif

    glEnable(GL_DEPTH_TEST);
    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);
    glFrontFace(GL_CCW);

    // Create a default 1x1 white texture for unfound specular maps
    unsigned char whitePixel[] = { 255, 255, 255 };
    glGenTextures(1, &white1x1TextureID);
    glBindTexture(GL_TEXTURE_2D, white1x1TextureID);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 1, 1, 0, GL_RGB, GL_UNSIGNED_BYTE, whitePixel);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glBindTexture(GL_TEXTURE_2D, 0);

    // Load the main model
    std::vector<Mesh> meshes1 = loadModel("C:/Users/HP PROBOOK 450 G7/Desktop/resident_evil_2_r.p.d_raccoon_police_station/scene.gltf");
    if (meshes1.empty()) {
        glfwTerminate();
        return -1;
    }

    // Skybox vertices (still the same for a cube)
    float skyboxVertices[] = {
        // positions
        -1.0f,  1.0f, -1.0f,
        -1.0f, -1.0f, -1.0f,
         1.0f, -1.0f, -1.0f,
         1.0f, -1.0f, -1.0f,
         1.0f,  1.0f, -1.0f,
        -1.0f,  1.0f, -1.0f,

        -1.0f, -1.0f,  1.0f,
        -1.0f, -1.0f, -1.0f,
        -1.0f,  1.0f, -1.0f,
        -1.0f,  1.0f, -1.0f,
        -1.0f,  1.0f,  1.0f,
        -1.0f, -1.0f,  1.0f,

         1.0f, -1.0f, -1.0f,
         1.0f, -1.0f,  1.0f,
         1.0f,  1.0f,  1.0f,
         1.0f,  1.0f,  1.0f,
         1.0f,  1.0f, -1.0f,
         1.0f, -1.0f, -1.0f,

        -1.0f, -1.0f,  1.0f,
        -1.0f,  1.0f,  1.0f,
         1.0f,  1.0f,  1.0f,
         1.0f,  1.0f,  1.0f,
         1.0f, -1.0f,  1.0f,
        -1.0f, -1.0f,  1.0f,

        -1.0f,  1.0f, -1.0f,
         1.0f,  1.0f, -1.0f,
         1.0f,  1.0f,  1.0f,
         1.0f,  1.0f,  1.0f,
        -1.0f,  1.0f,  1.0f,
        -1.0f,  1.0f, -1.0f,

        -1.0f, -1.0f, -1.0f,
        -1.0f, -1.0f,  1.0f,
         1.0f, -1.0f, -1.0f,
         1.0f, -1.0f, -1.0f,
        -1.0f, -1.0f,  1.0f,
         1.0f, -1.0f,  1.0f
    };

    // Skybox VAO, VBO setup
    // Define VAO and VBO for the skybox cube
    GLuint skyboxVAO, skyboxVBO; 
    glGenVertexArrays(1, &skyboxVAO);
    glGenBuffers(1, &skyboxVBO);
    glBindVertexArray(skyboxVAO);
    glBindBuffer(GL_ARRAY_BUFFER, skyboxVBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(skyboxVertices), &skyboxVertices, GL_STATIC_DRAW);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
    glBindVertexArray(0); // Unbind VAO

    // === Load the equirectangular HDR texture ===
    // Make sure "sky.hdr" exists at this path and is a valid equirectangular HDR file.
    // Loads the HDR equirectangular texture for the skybox environment.
    GLuint hdrEquirectangularTexture = loadHDREquirectangularTexture("C:/Users/HP PROBOOK 450 G7/source/repos/Modelo 3d/Modelo 3d/sky.hdr");
    if (hdrEquirectangularTexture == 0) {
        std::cerr << "Could not load the equirectangular HDR texture. The skybox will not be rendered." << std::endl;
        // Here you can choose to exit or continue without the skybox
    }


    // === Skybox Shaders for Equirectangular Texture ===
    // Vertex shader source for the skybox, tailored for equirectangular texture.
    const char* skybox_vs_src = R"(
#version 330 core
layout (location = 0) in vec3 aPos;

out vec3 WorldPos; // We pass the vertex position (direction in space)

uniform mat4 projection;
uniform mat4 view;

void main()
{
    WorldPos = aPos; // The cube vertex position is our direction
    // Remove translation from the view matrix to keep the skybox centered on the camera
    mat4 rotView = mat4(mat3(view));
    gl_Position = projection * rotView * vec4(aPos, 1.0);
    // Force the 'z' component to 'w' to ensure the skybox is always at the furthest possible depth
    gl_Position = gl_Position.xyww;
}
)";

    // Fragment shader source for the skybox, samples from an equirectangular texture.
    const char* skybox_fs_src = R"(
#version 330 core
out vec4 FragColor;

in vec3 WorldPos; // Direction from the camera

uniform sampler2D equirectangularMap; // Now a 2D sampler for the equirectangular texture

void main()
{
    // Normalize the direction to use as a sampling vector
    vec3 N = normalize(WorldPos);

    // Convert the direction vector (N) to spherical (UV) coordinates for the equirectangular texture
    vec2 uv;
    // Azimuth (horizontal)
    uv.x = atan(N.z, N.x) / (2.0 * 3.14159265359) + 0.5;
    // Elevation (vertical)
    uv.y = asin(N.y) / 3.14159265359 + 0.5; // glm::pi<float>()

    // Sample the equirectangular texture
    vec3 color = texture(equirectangularMap, uv).rgb;
    FragColor = vec4(color, 1.0);
}
)";

    // Create skybox shader program (using the new shaders)
    // Compiles and links the skybox shaders into a program.
    GLuint skyboxShaderProgram = createShaderProgram(skybox_vs_src, skybox_fs_src);
    if (skyboxShaderProgram == 0) {
        glfwTerminate();
        return -1;
    }
    // Assign the texture unit for the equirectangular texture sampler
    // Sets the texture unit for the equirectangular map uniform in the skybox shader.
    glUseProgram(skyboxShaderProgram);
    glUniform1i(glGetUniformLocation(skyboxShaderProgram, "equirectangularMap"), 0); // The HDR texture uses texture unit 0


    // Original model lighting shaders (unchanged in this update)
    const char* vsSrc = R"(
#version 330 core
layout (location = 0) in vec3 position;
layout (location = 1) in vec3 normal;
layout (location = 2) in vec2 texCoords;

out vec3 Normal;
out vec3 FragPos;
out vec2 TexCoords;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    gl_Position = projection * view * model * vec4(position, 1.0f);
    FragPos = vec3(model * vec4(position, 1.0f));
    Normal = mat3(transpose(inverse(model))) * normal;
    TexCoords = texCoords;
}
)";

    const char* fsSrc = R"(
#version 330 core
struct Material
{
    sampler2D diffuse;
    sampler2D specular;
    float     shininess;
};

struct Light
{
    vec3 position;
    vec3 direction;
    float cutOff;
    float outerCutOff;
    
    float constant;
    float linear;
    float quadratic;
    
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};

in vec3 FragPos;
in vec3 Normal;
in vec2 TexCoords;

out vec4 color;

uniform vec3 viewPos;
uniform Material material;
uniform Light light;
uniform bool flashlightIsActive;

void main()
{
    vec3 matAmbient  = vec3(texture(material.diffuse, TexCoords));
    vec3 matDiffuse  = vec3(texture(material.diffuse, TexCoords));
    vec3 matSpecular = vec3(texture(material.specular, TexCoords));

    if (!flashlightIsActive) {
        // If the flashlight is not active, only apply general ambient light or no light.
        color = vec4(matAmbient * light.ambient, 1.0f);
        return;
    }

    vec3 ambient = light.ambient * matAmbient;
    
    vec3 norm = normalize(Normal);
    vec3 lightDir = normalize(light.position - FragPos);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = light.diffuse * diff * matDiffuse; // <-- CORRECTED: light.diffuse
    
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 reflectDir = reflect(-lightDir, norm);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    vec3 specular = light.specular * spec * matSpecular;
    
    float theta = dot(lightDir, normalize(-light.direction));
    float epsilon = (light.cutOff - light.outerCutOff);
    float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);
    
    if (theta > light.outerCutOff) {
        diffuse  *= intensity;
        specular *= intensity;
    } else {
        diffuse  = vec3(0.0);
        specular = vec3(0.0);
    }

    float distance    = length(light.position - FragPos);
    float attenuation = 1.0f / (light.constant + light.linear * distance + light.quadratic * (distance * distance));
    ambient  *= attenuation;
    diffuse  *= attenuation;
    specular *= attenuation;
    
    color = vec4(ambient + diffuse + specular, 1.0f);
}
)";

    GLuint prog = createShaderProgram(vsSrc, fsSrc);
    if (prog == 0) {
        glfwTerminate();
        return -1;
    }

    glUseProgram(prog);
    // Configure samplers for material textures (Unit 0 for diffuse, Unit 1 for specular)
    glUniform1i(glGetUniformLocation(prog, "material.diffuse"), 0);
    glUniform1i(glGetUniformLocation(prog, "material.specular"), 1);

    // General light property configuration (which the flashlight will use)
    glUniform3f(glGetUniformLocation(prog, "light.ambient"), 5.0f, 5.0f, 5.0f); // General ambient light
    glUniform3f(glGetUniformLocation(prog, "light.diffuse"), 5.0f, 5.5f, 5.8f);     // Diffuse color of the flashlight
    glUniform3f(glGetUniformLocation(prog, "light.specular"), 1.0f, 1.0f, 1.0f);  // Specular color of the flashlight

    // Attenuation parameters for a distance light (e.g., torch or flashlight)
    glUniform1f(glGetUniformLocation(prog, "light.constant"), 1.0f);
    glUniform1f(glGetUniformLocation(prog, "light.linear"), 0.09f);
    glUniform1f(glGetUniformLocation(prog, "light.quadratic"), 0.032f);

    // Adjust flashlight cone angles (in degrees, then converted to cosine in code)
    const float INNER_CONE_ANGLE_DEGREES = 10.5f;
    const float OUTER_CONE_ANGLE_DEGREES = 15.5f;
    glUniform1f(glGetUniformLocation(prog, "light.cutOff"), glm::cos(glm::radians(INNER_CONE_ANGLE_DEGREES)));
    glUniform1f(glGetUniformLocation(prog, "light.outerCutOff"), glm::cos(glm::radians(OUTER_CONE_ANGLE_DEGREES)));

    glUniform1f(glGetUniformLocation(prog, "material.shininess"), 32.0f);

    float dT = 0.0f, lFT = 0.0f; // deltaTime and lastFrameTime
    while (!glfwWindowShouldClose(win)) {
        float cFT = static_cast<float>(glfwGetTime());
        dT = cFT - lFT;
        lFT = cFT;

        processInput(win, dT); // Process user input

        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        // --- Render the Skybox ---
        // Change the depth function to GL_LEQUAL so the skybox draws at the furthest depth.
        glDepthFunc(GL_LEQUAL); 
        // Use the skybox shader program.
        glUseProgram(skyboxShaderProgram);
        // Create the view matrix for the skybox, removing translation.
        glm::mat4 skyboxView = glm::mat4(glm::mat3(camera.GetViewMatrix())); 
        // Create the projection matrix for the skybox.
        glm::mat4 skyboxProjection = glm::perspective(glm::radians(camera.GetZoom()), (float)sW / (float)sH, 0.1f, 1000.0f);

        // Pass the view matrix to the skybox shader.
        glUniformMatrix4fv(glGetUniformLocation(skyboxShaderProgram, "view"), 1, GL_FALSE, glm::value_ptr(skyboxView));
        // Pass the projection matrix to the skybox shader.
        glUniformMatrix4fv(glGetUniformLocation(skyboxShaderProgram, "projection"), 1, GL_FALSE, glm::value_ptr(skyboxProjection));

        // Draw the skybox cube
        // Bind the skybox VAO.
        glBindVertexArray(skyboxVAO);
        // Activate texture unit 0 for the equirectangular map.
        glActiveTexture(GL_TEXTURE0); 
        // Bind the HDR equirectangular texture to texture unit 0.
        glBindTexture(GL_TEXTURE_2D, hdrEquirectangularTexture); 
        // Draw the skybox using 36 vertices (a cube).
        glDrawArrays(GL_TRIANGLES, 0, 36);
        // Unbind the skybox VAO.
        glBindVertexArray(0);
        // Restore the depth function to GL_LESS for rendering the rest of the scene.
        glDepthFunc(GL_LESS); 

        // --- Render the main scene ---
        glUseProgram(prog); // Switch back to the model shader program
        glm::mat4 vM = camera.GetViewMatrix(); // Get the camera's view matrix
        glm::mat4 pM = glm::perspective(glm::radians(camera.GetZoom()), (float)sW / (float)sH, 0.1f, 1000.0f); // Use camera zoom

        glUniformMatrix4fv(glGetUniformLocation(prog, "view"), 1, GL_FALSE, glm::value_ptr(vM));
        glUniformMatrix4fv(glGetUniformLocation(prog, "projection"), 1, GL_FALSE, glm::value_ptr(pM));
        glUniform3fv(glGetUniformLocation(prog, "viewPos"), 1, glm::value_ptr(camera.GetPosition())); // Camera position for specular calculation

        // Send flashlight state to the shader
        glUniform1i(glGetUniformLocation(prog, "flashlightIsActive"), flashlightOn ? 1 : 0);

        // The flashlight's light now emanates from the camera's position and points in the camera's front direction.
        glUniform3fv(glGetUniformLocation(prog, "light.position"), 1, glm::value_ptr(camera.GetPosition()));
        glUniform3fv(glGetUniformLocation(prog, "light.direction"), 1, glm::value_ptr(camera.GetFront()));

        glm::mat4 m1TF = glm::rotate(glm::mat4(1.0f), glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.0f));
        glUniformMatrix4fv(glGetUniformLocation(prog, "model"), 1, GL_FALSE, glm::value_ptr(m1TF));
        for (const auto& m : meshes1) renderMesh(m, prog);

        glfwSwapBuffers(win);
        glfwPollEvents();
    }
    // Resource cleanup when closing the window
    auto cleanup = [](const auto& M) {
        for (const auto& m : M) {
            if (m.VAO) glDeleteVertexArrays(1, &m.VAO);
            // We don't explicitly delete VBO/EBO here because they are associated with the VAO,
            // and glDeleteVertexArrays usually unbinds and deletes associated buffers.
            // For greater safety or if buffers are independent, glDeleteBuffers would be used.
            if (m.textureID) glDeleteTextures(1, &m.textureID);
            if (m.specularTextureID) glDeleteTextures(1, &m.specularTextureID); // Also clean up the specular texture
        }
    };
    cleanup(meshes1);
    glDeleteProgram(prog);
    glDeleteTextures(1, &white1x1TextureID); // Delete the default white texture

    // Skybox resource cleanup
    // Delete the skybox VAO.
    glDeleteVertexArrays(1, &skyboxVAO);
    // Delete the skybox VBO.
    glDeleteBuffers(1, &skyboxVBO); 
    // Delete the skybox shader program.
    glDeleteProgram(skyboxShaderProgram);
    
    // IMPORTANT! Clean up the new equirectangular HDR texture
    // Delete the HDR equirectangular texture.
    if (hdrEquirectangularTexture != 0) {
        glDeleteTextures(1, &hdrEquirectangularTexture);
    }
    // The line for 'cubemapTexture' is no longer needed, I've commented it out above.

    glfwTerminate();
    return 0;
}
